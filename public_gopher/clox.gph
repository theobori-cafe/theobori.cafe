[i|## title: My bytecode VM Lox interpreter|/|tilde.pink|70]
[i|## date: "2024-10-06"|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|The aim of this post is to describe the general operation of|/|tilde.pink|70]
[i|the program and some of the mechanisms that we consider to|/|tilde.pink|70]
[i|be of interest. For full details, a link to the source code|/|tilde.pink|70]
[i|is available at the bottom of the page.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|So I continued with “Crafting Interpreters” by Robert|/|tilde.pink|70]
[i|Nystrom after making My Tree-Walker Lox interpreter. In this|/|tilde.pink|70]
[i|part I tried to do as many challenges as possible and really|/|tilde.pink|70]
[i|understand how a VM bytecode works.|/|tilde.pink|70]
[1|My Tree-Walker Lox interpreter|/~nagi/posts/jlox|tilde.pink|70]
[i||/|tilde.pink|70]
[i|This version is written in C, which means we have to write a|/|tilde.pink|70]
[i|lot of code ourselves, but we don't use any external|/|tilde.pink|70]
[i|libraries.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|## Compiler|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|The primary purpose of our compiler is to generate a chunk|/|tilde.pink|70]
[i|of code in bytecode form for interpretation by our bytecode|/|tilde.pink|70]
[i|virtual machine. Here are a few interesting features of the|/|tilde.pink|70]
[i|front end.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|### Scanner|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|The token scanner is very classic, with only one thing to|/|tilde.pink|70]
[i|say: the function responsible for identifying the language's|/|tilde.pink|70]
[i|native keywords is very dirty. The author has chosen to use|/|tilde.pink|70]
[i|a large switch statement instead of implementing a sorting|/|tilde.pink|70]
[i|function, which is certainly powerful but not very elegant.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|### Parser|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|An interesting point to note is that the author chose not to|/|tilde.pink|70]
[i|use a syntax tree for the front end. We therefore|/|tilde.pink|70]
[i|implemented a single-pass compiler (directly converts compile|/|tilde.pink|70]
[i|units into bytecode).|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|We also implemented a Vaughan Pratt's parser, in our case a|/|tilde.pink|70]
[i|“top-down operator precedence parser”. This means we have to|/|tilde.pink|70]
[i|define operator precedence in advance. Here's what it looks|/|tilde.pink|70]
[i|like in code.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|typedef enum {|/|tilde.pink|70]
[i|  PREC_NONE,|/|tilde.pink|70]
[i|  PREC_ASSIGNMENT, // =|/|tilde.pink|70]
[i|  PREC_OR,         // or|/|tilde.pink|70]
[i|  PREC_AND,        // and|/|tilde.pink|70]
[i|  PREC_EQUALITY,   // == !=|/|tilde.pink|70]
[i|  PREC_COMPARISON, // < > <= >=|/|tilde.pink|70]
[i|  PREC_TERM,       // + -|/|tilde.pink|70]
[i|  PREC_FACTOR,     // * /|/|tilde.pink|70]
[i|  PREC_UNARY,      // ! -|/|tilde.pink|70]
[i|  PREC_CALL,       // . ()|/|tilde.pink|70]
[i|  PREC_PRIMARY|/|tilde.pink|70]
[i|} Precedence;|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|This precedence is simply used to control the parsing of|/|tilde.pink|70]
[i|expressions. A rule with a lower precedence than the last|/|tilde.pink|70]
[i|parsed expression is not allowed.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|## Bytecode|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|To manage conditions, we emit OP_JUMP operation code for|/|tilde.pink|70]
[i|conditions. If a condition expression is evaluated to false,|/|tilde.pink|70]
[i|it jumps to the end of the conditionnal block / expression.|/|tilde.pink|70]
[i|To do this, we use the concept of backpatching: we overwrite|/|tilde.pink|70]
[i|the immediate value of the instruction in the chunk during|/|tilde.pink|70]
[i|compilation.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|In my implementation, all immediate values are encoded on 8|/|tilde.pink|70]
[i|bits, with the exception of constants, which have a size of|/|tilde.pink|70]
[i|24 bits.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|## Virtual Machine|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|The VM is centered on a stack where we push operands, local|/|tilde.pink|70]
[i|variables, etc..|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|Everything at runtime is managed by callframes, even the top-|/|tilde.pink|70]
[i|level code is embed within a function object.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|## Example|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|Here is a simple Lox example that can be evaluated by my|/|tilde.pink|70]
[i|interpreter.|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|fun fib(n) {|/|tilde.pink|70]
[i|    if (n < 2) {|/|tilde.pink|70]
[i|        return n;|/|tilde.pink|70]
[i|    }|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|    return fib(n - 2) + fib(n - 1);|/|tilde.pink|70]
[i|}|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|print fib(10);|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|## Links|/|tilde.pink|70]
[i||/|tilde.pink|70]
[i|https://github.com/theobori/lox-virtual-machine|/|tilde.pink|70]
[h|https://github.com/theobori/lox-virtual-machine|URL:https://github.com/theobori/lox-virtual-machine|github.com|443]
