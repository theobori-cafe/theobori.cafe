{
    "version": "https://jsonfeed.org/version/1",
    "title": "Théo Bori",
    "home_page_url": "http://localhost:3000",
    "feed_url": "http://localhost:3000/rss/feed.json",
    "description": "Posts and archives about things I make",
    "icon": "http://localhost:3000/favicon.png",
    "author": {
        "name": "Théo Bori",
        "url": "https://www.github.com/theobori"
    },
    "items": [
        {
            "id": "http://localhost:3000/post/theoboricafe",
            "content_html": "\n# ~\n\nThe aim of the project is to provide open source services to anyone who wants to use them. For the moment, the machine(s) used are small and consequently there are a limited number of services and features. This can of course evolve over time, depending on resources and motivation. So, if you're looking for performance above all else, I'd recommend [deuxfleurs.fr](https://deuxfleurs.fr/) or [chatons.org](https://www.chatons.org/). To use some of them, you'll need to send me an e-mail **`himself at theobori dot cafe`**.\n\nIt's all about privacy and security. The aim is to be able to use simple and efficient services such as Joplin or SearXNG, but also to avoid Google, Microsoft, etc. Server configuration and DNS entries are automated and open source on GitHub. See [theobori-cafe organization](https://github.com/theobori-cafe).\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/searxng.svg\" width=\"70%\">\n</p>\n\nServices status can be checked at [status.theobori.cafe](https://status.theobori.cafe).\n\nWhile setting up the server(s) and services, I learned some interesting things about network and system security. By the way, an onion (Tor) service is available.\n\nnioaz2guqngy62mtld7gjeeivlkpai2m6h5isryorfys7mhubargcuid.onion.\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/tor_logo.svg\" width=\"40%\">\n</p>\n\nI've chosen to use a Joplin server instead of Nextcloud for lack of resources, and plan to have an instance as soon as possible!\n",
            "url": "http://localhost:3000/post/theoboricafe",
            "title": "Open source services",
            "summary": "Provides privacy-friendly open source services on a tiny server.",
            "date_modified": "2023-09-24T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/teeworlds-utilities",
            "content_html": "\n# ~\n\nThis idea came to me when I was looking for a Teeworlds skin renderer.\n\nThe ones that existed didn't suit me, as they didn't really respect the in-game rendering. Either the feet were too far out or the colors were wrong.\n\nSo I decided to make my own toolbox to manipulate Teeworlds assets, which we use on skins.tw and for the Teeworlds Data Discord bot. \nIndirectly, other people use it, for example, to render skins in a Discord channel that displays messages in real time (fokkonaut's Discord server)\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/fokkonaut_bridge.png\">\n</p>\n\nor in other projects like [TeeAssembler 2.0](https://teeassembler.developer.li/) that used some part of the **`teeworlds-utilites`** code.\n\n# Use cases\n\n### Teeworlds skin rendering\n\nRender a Teeworlds 4K skin with default and custom colors.\n\n```typescript\nimport {\n  Skin,\n  ColorCode,\n  ColorRGB\n} from 'teeworlds-utilities';\n\nconst renderTest = async () => {\n  const skin = new Skin();\n\n  await skin.load('https://api.skins.tw/database/skins/96AATxN3DEzcGww4QhmduFCsPzaxhZO7Tq6Lh9OI.png');\n\n  skin\n    .render()\n    .saveRenderAs('default.png')\n    .colorTee(\n      new ColorCode(6619008),\n      new ColorRGB(136, 113, 255),\n    )\n    .render()\n    .saveRenderAs('color.png');\n}\n\ntry {\n  renderTest();\n} catch (err) {\n  console.error(err);\n}\n```\n\n### Rendered skins\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/render_color.png\" width=\"40%\">\n  <img src=\"/render_default.png\" width=\"40%\">\n</p>\n\n### Scene\n\nA custom scene including a rendered skin.\n\n```typescript\nimport { Scene } from 'teeworlds-utilities';\n\nconst sceneTest = async () => {\n  const scene = new Scene(\n    'data/scenes/schemes/example.json'\n  ).preprocess();\n\n  await scene.renderScene();\n  scene.saveScene('scene.png')\n}\n\nsceneTest();\n```\n\n### Rendered scene\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/scene.png\" width=\"80%\">\n</p>\n\n### Merge asset parts\n\nHere we are going to merge specific parts from a skin (right) to another (left).\n\nAny Teeworlds asset should works.\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/ahl_skin.png\">\n  <img src=\"/bit_skin.png\" width=\"216px\">\n</p>\n\n\n```typescript\nimport {\n  Skin,\n  SkinPart\n} from 'teeworlds-utilities';\n\nconst mergeTest = async () => {\n  const skin = new Skin();\n  await skin.load('https://api.skins.tw/database/skins/OUZsYUrmUkitNBUAtKyxdiH5EnLBTkBy8tKNPVmi.png');\n\n  const skin_src = new Skin();\n  await skin_src.load('https://api.skins.tw/database/skins/6l7fEywyc0hnchjJAqEHVLmYVJIlNe2Cv6HJVNcR.png');\n\n  skin\n    .copyParts(\n      skin_src,\n      SkinPart.FOOT,\n      SkinPart.FOOT_SHADOW,\n      SkinPart.DEFAULT_EYE,\n      SkinPart.ANGRY_EYE,\n      SkinPart.BLINK_EYE,\n      SkinPart.CROSS_EYE,\n      SkinPart.HAPPY_EYE,\n      SkinPart.SCARY_EYE,\n      SkinPart.HAND_SHADOW,\n      SkinPart.HAND,\n    )\n    .setEyeAssetPart(SkinPart.ANGRY_EYE)\n    .render()\n    .saveAs('skin.png')\n    .saveRenderAs('skin.png')\n}\n\ntry {\n  mergeTest();\n} catch (err) {\n  console.error(err);\n}\n```\n\n### New skin\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/render_new_skin.png\">\n  <img src=\"/new_skin.png\">\n</p>\n\n# Other renders\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/skin_weapon.png\">\n  <img src=\"/skin_weapon_color.png\">\n</p>\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/board.png\">\n</p>\n\n# Try\n\n[*Source*](https://github.com/teeworlds-utilities/teeworlds-utilities)\n",
            "url": "http://localhost:3000/post/teeworlds-utilities",
            "title": "Teeworlds utilities",
            "summary": "Asset utilities including skin rendering, extracting, editing and many more for the Teeworlds community.",
            "date_modified": "2023-07-26T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/tf-neuvector",
            "content_html": "\n# ~\n\nThis project is used to manage NeuVector's configuration and its most revelant resources. I was asked to automate the configuration of the solution in a fairly specific context. Initially, I had made a rather well-organized bash script that could apply these resources, but not destroy them.\n\nI then asked around and very quickly found Terraform. So I learned how to use it and made a module that could manage any NeuVector resource, including creation and destruction only.\n\nA huge problem was the token that NeuVector provides tends to timeout quite quickly (300 seconds by default).\nSo I decided to create a Terraform provider to handle all this cleanly. The language best suited for this is Go, so I learned it. Hashicorp explains that it's best to separate the client library from the provider.\n\n<p align=\"center\" width=\"100%\">\n    <img src=\"/terraform_provider.png\" width=\"90%\">\n</p>\n\nSo I created a Go SDK for NeuVector before using it in the provider, you can find it out [here](https://github.com/theobori/go-neuvector).\n\nNow the provider is able to fully manage the implemented resources (create, delete, update and import).\n\n# Use cases\n\nThe provider Terraform block looks like below.\n\n```\nterraform {\n  required_providers {\n    neuvector = {\n      source = \"theobori/neuvector\"\n      version = \"0.4.1\"\n    }\n  }\n}\n\nprovider \"neuvector\" {\n  base_url = \"https://127.0.0.1:10443/v1/\"\n  username = \"admin\"\n  password = \"admin\"\n}\n```\n\nOnce it is declared in the configuration, you can start using it as you want. Here's a Terraform example that could be applied after installing NeuVector.\n\n```\nresource \"neuvector_eula\" \"eula\" {\n    accepted = true\n}\n\nresource \"neuvector_registry\" \"registry_test\" {\n  name                   = \"docker.io\"\n  registry_type          = \"Docker Registry\"\n  filters                = [\"*\"]\n  registry               = \"https://registry.hub.docker.com/\"\n  rescan_after_db_update = true\n  auth_with_token        = false\n  scan_layers            = true\n}\n\nresource \"neuvector_group\" \"group_test\" {\n  name = \"mytestgroup\"\n\n  criteria {\n    key   = \"pattern\"\n    value = \"[a-z]\"\n    op    = \"regex\"\n  }\n\n  criteria {\n    key   = \"namespace\"\n    value = \"example\"\n    op    = \"=\"\n  }\n}\n\ndata \"neuvector_group_metadata\" \"group_metadata\" {\n    name = neuvector_group.group_test.id\n}\n\nresource \"neuvector_service_config\" \"service_config_test\" {\n  services = data.neuvector_group_services.group_metadata.services\n\n  not_scored = true\n}\n```\n\n# Try\n\n[*Source*](https://github.com/theobori/terraform-provider-neuvector)\n",
            "url": "http://localhost:3000/post/tf-neuvector",
            "title": "Terraform NeuVector provider",
            "summary": "A Terraform provider to configure NeuVector and manage its resources.",
            "date_modified": "2023-06-04T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/tf-doom",
            "content_html": "\n# ~\n\nI first saw [kubedoom](https://github.com/storax/kubedoom) and thought it was pretty cool, so I decided to do the same for Terraform, knowing that I was working with it for professional projects. \n\nThe principle is very simple, each enemy represents a Terraform resource, if an enemy dies, the associated resource is destroyed.\n\n# How it works ?\n\nThe main program is **`tf-doom`**', which creates a UNIX socket, listens to it and simultaneously launches an X11 virtual server (Xvfb), a VNC server (x11vnc) attached to this X session and **`psdoom`** (DOOM writing to the UNIX socket). \n\nEverything we've just described will be encapsulated in a Docker container.\n\nThe binaries **`Xvfb`** and **`x11vnc`** are used to create a cross-platform graphical access to **`psdoom`** inside the container.\n\n**`psdoom`** will continuously write to the UNIX socket to signal **`tf-doom`** to send Terraform resource information. When an enemy is killed, **`psdoom`** writes the associated resource name to the socket.\n\n<p align=\"center\" width=\"100%\">\n    <img src=\"/tf-doom.png\" width=\"80%\">\n</p>\n\n# Demo\n\nThis demo has been realized with the test Terraform project, every steps to reproduce it are detailed in the README file on the repository.\n\n<p align=\"center\" width=\"100%\">\n    <video controls width=\"80%\">\n        <source src=\"/tf-doom.mp4\" type=\"video/mp4\">\n        <a href=\"/tf-doom.mp4\">MP4</a>\n    </video>\n</p>\n\n# Try\n\n[*Source*](https://github.com/theobori/tf-doom)\n",
            "url": "http://localhost:3000/post/tf-doom",
            "title": "Terraform chaos engineering",
            "summary": "Destroy Terraform resource by killing DOOM enemies.",
            "date_modified": "2023-06-03T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/tinywad",
            "content_html": "\n# ~\n\nThis project is a WAD library/manager, it can be used as a base for other WAD projects like a GUI, a CLI, etc..\n\nI have played around with some well known `IWAD` like **`doom.wad`** and **`doom2.wad`** (registered).\n\nTo test the `IWAD`/`PWAD` generated, I have used two engines:\n- [GZDoom](https://zdoom.org/index) (tests + screenshots)\n- [WAD Commander](https://wadcmd.com/) (tests + preview in multiple contexts)\n\n# Use cases\n\nSome use cases you could use in a DOOM modding context.\n\n### IWAD patching\n\n```rust\nuse tinywad::error::WadError;\nuse tinywad::models::operation::WadOp;\nuse tinywad::wad::Wad;\n\nfn main() -> Result<(), WadError> {\n    let mut doom_2 = Wad::new();\n    doom_2.load_from_file(\"wads/doom2.wad\")?;\n\n    let gate = doom_2.lump(\"GATE3\").unwrap();\n\n    let mut doom_1 = Wad::new();\n    doom_1.load_from_file(\"doom1.wad\")?;\n\n    doom_1.select(\"^FLAT|FLOOR\");\n    doom_1.update_lumps_raw(&gate.data().buffer);\n    doom_1.save(\"doom1.wad\");\n\n    Ok(())\n}\n```\n\nSo basically (above) it loads a first `IWAD` file, in our case it is **`doom2.wad`**. It borrows a lump (**`GATE3`**) into the variable **`gate`**, then we load a second `IWAD` which is **`doom1.wad`**, it selects desired lumps, then it update the selected lumps in `DOOM1` and finally overwrite the file.\n\n### Screenhot(s)\n\n<img src=\"/doom_gate3.png\" width=\"60%\">\n\n### Lumps extracting\n\n```rust\nuse std::fs;\n\nuse tinywad::dir::MAX_PAL;\nuse tinywad::error::WadError;\nuse tinywad::models::operation::WadOp;\nuse tinywad::wad::Wad;\n\nfn main() -> Result<(), WadError> {\n    let mut doom_2 = Wad::new();\n    doom_2.load_from_file(\"wads/doom2.wad\")?;\n\n    for pal in 0..MAX_PAL {\n        doom_2.set_palette(pal);\n        doom_2.reload()?;\n        doom_2.select(\"^BOSF\");\n        \n        let dirpath = format!(\"doom2/pal_{}\", pal);\n\n        fs::create_dir_all(dirpath.clone()).unwrap();\n\n        doom_2.save_lumps(dirpath);\n    }\n\n    Ok(())\n}\n```\n\nIn this part of code, it extracts as PNG the selected lumps with different palettes (13).\n\n### Extracted lumps (as PNGs)\n\n<p float=\"left\">\n  <img src=\"/doom2/pal_0/BOSFB0.png\">\n  <img src=\"/doom2/pal_1/BOSFB0.png\">\n  <img src=\"/doom2/pal_2/BOSFB0.png\">\n  <img src=\"/doom2/pal_3/BOSFB0.png\">\n  <img src=\"/doom2/pal_4/BOSFB0.png\">\n  <img src=\"/doom2/pal_5/BOSFB0.png\">\n  <img src=\"/doom2/pal_6/BOSFB0.png\">\n  <img src=\"/doom2/pal_7/BOSFB0.png\">\n  <img src=\"/doom2/pal_8/BOSFB0.png\">\n  <img src=\"/doom2/pal_9/BOSFB0.png\">\n  <img src=\"/doom2/pal_10/BOSFB0.png\">\n  <img src=\"/doom2/pal_11/BOSFB0.png\">\n  <img src=\"/doom2/pal_12/BOSFB0.png\">\n</p>\n\n### Dumping metadata\n\n```rust\nuse tinywad::error::WadError;\nuse tinywad::models::operation::WadOp;\nuse tinywad::wad::Wad;\n\nfn main() -> Result<(), WadError> {\n    let mut src = Wad::new();\n\n    src.load_from_file(\"wads/hexen.wad\")?;\n    src.dump();\n\n    Ok(())\n}\n```\n\n### Output\n\n```\nName: XXTIC, Size: 8, Offset: 12\nName: STARTUP, Size: 153648, Offset: 20\nName: PLAYPAL, Size: 21504, Offset: 153668, Palettes amount: 28\nName: COLORMAP, Size: 8704, Offset: 175172\nName: FOGMAP, Size: 8704, Offset: 183876\nName: TINTTAB, Size: 65536, Offset: 192580\nName: TRANTBL0, Size: 256, Offset: 258116\nName: TRANTBL1, Size: 256, Offset: 258372\nName: TRANTBL2, Size: 256, Offset: 258628\n...\n```\n\n### Building a PWAD from scratch\n\n```rust\nuse tinywad::error::WadError;\nuse tinywad::lump::{LumpAdd, LumpAddKind};\nuse tinywad::models::operation::WadOp;\nuse tinywad::wad::{Wad, WadKind,};\n\nfn main() -> Result<(), WadError> {\n    let mut src = Wad::new();\n\n    let lump_names = [\n        \"FLOOR0_1\", \"FLOOR0_3\", \"FLOOR0_6\",\n        \"FLOOR1_1\", \"FLOOR1_7\", \"FLOOR3_3\",\n        \"FLOOR4_1\", \"FLOOR4_5\", \"FLOOR4_6\",\n        \"FLOOR4_8\", \"FLOOR5_1\", \"FLOOR5_2\",\n        \"FLOOR5_3\", \"FLOOR5_4\", \"FLOOR6_1\",\n        \"FLOOR6_2\", \"FLOOR7_1\", \"FLOOR7_2\",\n    ];\n\n    src.load_from_file(\"doom.wad\")?;\n\n    let gate = src.lump(\"FLOOR6_1\").unwrap();\n\n    let mut dest = Wad::new();\n\n    dest.set_kind(WadKind::Pwad);\n    dest.add_lump_raw(\n        LumpAdd::new(\n            LumpAddKind::Back,\n            &vec![],\n            \"FF_START\",\n        )\n    )?;\n\n    for lump_name in lump_names {\n        dest.add_lump_raw(\n            LumpAdd::new(\n                LumpAddKind::Back,\n                &gate.data().buffer,\n                lump_name,\n            )\n        )?;\n    }\n\n    dest.add_lump_raw(\n        LumpAdd::new(\n            LumpAddKind::Back,\n            &vec![],\n            \"F_END\",\n        )\n    )?;\n\n    dest.save(\"doom1_patch.wad\");\n\n    Ok(())\n}\n```\n\nTo take the screenshot (below) **`doom1_patch.wad`** has been injected into GZDOOM with the `IWAD` **`doom.wad`** (registered).\n\n### Screenshot(s)\n\n<img src=\"/doom_floor6_1.png\" width=\"60%\">\n\n### Download files(s)\n\n[`doom1_patch.wad`](/doom1_patch.wad)  \n[`doom1_patch.asc`](/doom1_patch.asc)  \n[`checksum`](/checksum.txt)\n\n### Extracting MIDI lumps\n\nExtracting every musics from the `IWAD` **`doom.wad`**.\n\n```rust\nuse tinywad::error::WadError;\nuse tinywad::models::operation::WadOp;\nuse tinywad::wad::{Wad};\n\nfn main() -> Result<(), WadError> {\n    let mut src = Wad::new();\n\n    src.load_from_file(\"doom.wad\")?;\n    src.select(\"D_\");\n    src.save_lumps(\".\");\n\n    Ok(())\n}\n```\n\n### `D_E1M1` converted from MIDI to MP3\n\n<figure>\n    <audio\n        controls\n        src=\"/D_E1M1.mp3\">\n    </audio>\n</figure>\n\n# Try\n\n[*Source*](https://github.com/theobori/tinywad)\n",
            "url": "http://localhost:3000/post/tinywad",
            "title": "DOOM modding",
            "summary": "A library for extracting, building, parsing and updating WAD files.",
            "date_modified": "2023-05-03T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/tinychip",
            "content_html": "\n# ~\n\nI wanted to learn the basics of emulator development and emulation in general. So I decided to make a chip8 emulator.\nIn fact it's a misuse of language to say that it's an \"emulator\" because chip8 is a language, so we should rather say \"interpreter\".\n\n# How does it works ?\n\nSo, basically there are three main components that make it works. The **CPU**, the **API** and the **Core** (kernel).\n\nThe API polls the keyboard inputs and send them to the CPU that put them in the right memory location.\nThe CPU fetch, decode and execute an instruction from a **ROM** (program or game), it can change the VRAM and the CPU registers, etc ..\nDepending of the CPU state, the window draw the VRAM throught the API.\n\nThere are approximately ~n instructions executed per second for a frequency of n hz (n is 500 by default).\nAnd the sound and delay timers are managed with 60hz.\n\n# Screenshots\n\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/breakout_320_160.png\">\n  <img src=\"/space_invaders_320_160.png\">\n</p>\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/ibm_logo_640_320.png\" width=\"640px\" height=\"320px\">\n</p>\n\n### CPU\n\nAlmost everything is managed by the CPU, RAM, VRAM, pressed hotkeys (keyboard inputs), the sound, etc...\n\n### API\n\nIt manages the graphical window and the sound and fills the CPU with the keyboard inputs.\n\n### Core\n\nThe core makes the links between this two components.\n\n# Some extra informations\n\nAs I said, it supports some quirks for specific instructions, because according to some old documents,`fx55`, `fx65`, `8xy6` and `8xye` dont have the same semantic depending of the machine they were implemeneted on.\n\nI implemented the 36 instructions + the 4 I was taking before to be compatible with more ROM.\n\n# Try\n\n[*Source*](https://github.com/theobori/tinychip)\n",
            "url": "http://localhost:3000/post/tinychip",
            "title": "CHIP-8 emulator",
            "summary": "A CHIP-8 emulator that is able to support multiple API(s) and interpreter(s) implementations, it also supports some quirks for load and shift instructions. Adjustable clock speed from 500hz to 2000hz.",
            "date_modified": "2023-03-08T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/websites",
            "content_html": "\n# ~\n\n- [tilde.team](https://tilde.team)\n- [tilde.pink](https://tilde.pink)\n- [landchad.net](https://landchad.net)\n- [rawtext.club](https://rawtext.club)\n- [suckless.org](https://suckless.org)\n- [libreboot.org](https://libreboot.org)\n- [hashbang.sh](https://hashbang.sh)\n- [nostr.com](https://nostr.com)\n- [roadmap.sh](https://roadmap.sh)\n- [0x0.st](https://0x0.st)\n- [anonfiles.com](https://anonfiles.com)\n- [syncthing.net](https://syncthing.net)\n- [wiby.me](https://wiby.me)\n- [ʞ.cc](https://xn--rpa.cc)\n- [cmpxchg8b.com](https://cmpxchg8b.com)\n- [xkcd.com](https://xkcd.com)\n- [swizec.com](https://swizec.com)\n- [thenewstack.io](https://thenewstack.io)\n- [sectordisk.pw](https://sectordisk.pw)",
            "url": "http://localhost:3000/post/websites",
            "title": "www",
            "summary": "A simple list of interesting websites",
            "date_modified": "2023-03-08T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/workflow",
            "content_html": "\n# ~\n\nI've been using only Linux for years now, I've almost always used GNOME and even i3 but without any real configuration effort. Now I have a working environment that I find very practical and that allows me to be fast and more comfortable.\n\n# Overview\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/workflow.png\">\n</p>\n\n# Theme: `Dracula`\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/dracula_logo.png\">\n</p>\n\nI have used the Dracula theme for almost every applications.\n\n# Environment\n\nI won't list every single software I use, but only my most frequently used and important ones (modern Rust apps, suckless, etc..).\n\n**`i3`**: As window manager, minimalist, pretty useful and suckless\n\n**`i3blocks`**: Status bar, customed with some Luke Smith scripts + mine\n\n**`rofi`**: Application launcher as a dmenu replacement\n\n**`rofimoji`**: Emoji manager / character picker\n\n**`wezterm`**: GPU-accelerated cross-platform terminal emulator and multiplexer, implemented in Rust\n\n**`tmux`**: Terminal multiplexer\n\n**`fish`**: Unix shell\n\n**`oh-my-fish`** plugins:\n  - `bobthefish`\n  - `peco`\n  - `bang-bang`\n  - `fish_logo`\n\n**`nix`**: Cross platform packager manager\n\n**`feh`**: Image viewer, used to set the wallpaper\n\n**`flameshot`**: Screenshot software\n\n**`slock`**: Suckless screen locker\n\n# Easy to install\n\nI have made an automatic installation with Ansible for a faster, easier and more customizable environment setup.\n\nThe Nix installation assumes that SELinux is disabled, because Nix has made its own security system.\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/nix_security.png\">\n</p>\n\n*Source: [Repository](https://github.com/theobori/self-config)*\n",
            "url": "http://localhost:3000/post/workflow",
            "title": "Linux environment workflow",
            "summary": "A reproducible environment based on i3 and rofi.",
            "date_modified": "2023-02-20T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/python-useful",
            "content_html": "\n# ~\n\nHere are some pieces of code that I have done in Python and that I use quite often in my projects.\n\n# Collection\n\n### Repeater\n\n```python\nimport threading\nfrom typing import Callable\n\nclass RepeatCall:\n    \"\"\"\n        Optimized object that will call a function every n seconds\n    \"\"\"\n\n    def __init__(\n      self, n: float,\n      callback: Callable,\n      *args: list, **kwargs: dict\n    ):\n        self._timer = None\n        self.n = n\n        self.callback = callback\n        self.args = args\n        self.kwargs = kwargs\n        self.callback(*self.args, **self.kwargs)\n        self.is_running = False\n\n        self.start()\n\n    def _run(self):\n        \"\"\"\n            Call the function\n        \"\"\"\n\n        self.is_running = False\n        self.start()\n        self.callback(*self.args, **self.kwargs)\n\n    def start(self):\n        \"\"\"\n            Start the reapeater\n        \"\"\"\n\n        self._timer = threading.Timer(self.n, self._run)\n        self._timer.start()\n        self.is_running = True\n\n    def stop(self):\n        \"\"\"\n            Cancel the thread, then it stops the \"loop\"\n        \"\"\"\n\n        self._timer.cancel()\n```\n\n### Checking bytes (used for file signature)\n\n```python\ndef signature_check(data: bytes, sig: bytes) -> bool:\n    \"\"\"\n        Check file signature\n    \"\"\"\n\n    return data[:len(sig)] == sig\n```\n\n### Fill lists\n\n```python\nfrom typing import Tuple, List, Any\n\ndef fill_min(*args: Tuple[List[Any]]) -> List[Any]:\n    \"\"\"\n        Set every list with the same length\n    \"\"\"\n\n    length = len(max(*args, key=len))\n    args = list(args)\n    \n    for i in range(len(args)):\n        args[i] += (length - len(args[i])) * [\" \"]\n\n    return args\n```\n\n### Create a list of list from a list\n\n```python\nfrom typing import List, Any\n\ndef make_groups(arr: List[Any], size: int) -> List[List[Any]]:\n    \"\"\"\n        Makes list of iterable with a constant size\n    \"\"\"\n\n    return [arr[i:i + size] for i in range(0, len(arr), size)]\n```\n\n### Key value system object + manager\n\n```python\nfrom typing import Union, Any, Callable\n\nclass Bind:\n    \"\"\"\n        Describing combination (key -- callback)\n    \"\"\"\n\n    def __init__(\n        self,\n        key: Any,\n        callback: Callable, *args: list, **kwargs: dict\n    ):\n        self.key = key\n        self.callback = callback\n        self.args = args\n        self.kwargs = kwargs\n\n    async def try_call(\n        self,\n        *additional_args: list, **additional_kwargs: dict\n    ) -> Any:\n        \"\"\"\n            Tries to call the stored function\n        \"\"\"\n\n        args = [*self.args, *additional_args]\n        kwargs = {**self.kwargs, **additional_kwargs}\n\n        try:\n            ret = await self.callback(*args, **kwargs)\n        except:\n            ret = self.callback(*args, **kwargs)\n\n        return ret\n\nclass Binds:\n    \"\"\"\n        Manages the Bind objects\n        hotkey --> function\n    \"\"\"\n\n    def __init__(self):\n        self.key_binding = {}\n\n    def __getitem__(self, key: Any) -> Union[Bind, None]:\n        if not key in self.key_binding.keys():\n            return None\n\n        return self.key_binding[key]\n\n    def add_bind(\n        self,\n        key: Any,\n        function: callable, *args: list, **kwargs: dict\n    ):\n        \"\"\"\n            Add a Bind to the dictionnary\n        \"\"\"\n\n        bind = Bind(key, function, *args, **kwargs)\n\n        self.key_binding[key] = bind\n\n    async def try_call_from_bind(\n        self,\n        key: Any,\n        *add_args: list, **add_kwargs: dict\n    ) -> Any:\n        \"\"\"\n            If the dictionnary key is found,\n            then it tries to call the associated function\n        \"\"\"\n\n        bind = self[key]\n\n        if not bind:\n            return False\n\n        return await bind.try_call(*add_args, **add_kwargs)\n```\n",
            "url": "http://localhost:3000/post/python-useful",
            "title": "Collection of useful Python stuff",
            "summary": "Pieces of code that I made and that I use often and that I find useful.",
            "date_modified": "2022-09-23T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        },
        {
            "id": "http://localhost:3000/post/nes-utilities",
            "content_html": "\n# ~\n\nI wanted to learn more about how the NES works, so I consulted the resources on [Nesdev Wiki](https://www.nesdev.org/wiki/Nesdev_Wiki) and I discovered that from an NES program (`.nes` file) you could do cool stuff like extracting some tilesets from the **CHR ROM** (**Character Read-Only Memory**) or a **PRNG** (**Pseudorandom Number Generator**) with the instructions interpreted by the NES.\n\n# `nes-utils-cli`\n\nI made an example binary that can run all the main features of the `nes-utils` library to make it more convenient to test.\n\n[*Source*](https://github.com/theobori/nes-utils-cli)\n\n# Tilesets dumping\n\nA NES program include a **16 bytes** header, we can represent it like this:\n\n```rust\nconst NES_HEADER_FIELDS_ORDER: [(&str, usize, usize); 9] = {\n    [\n        (\"magic\", 0, 4),\n        (\"len_prg_rom\", 4, 1),\n        (\"len_chr_rom\", 5, 1),\n        (\"f6\", 6, 1),\n        (\"f7\", 7, 1),\n        (\"len_prg_ram\", 8, 1),\n        (\"f9\", 9, 1),\n        (\"f10\", 10, 1),\n        (\"reserved\", 11, 5)\n    ]\n};\n```\n\nIn this example, the field **magic** is at position **0** and has a lenght of **4** bytes.\n\nThe **CHR ROM** is linked to the **PPU** (**Picture Process Unit**), it means if the **CHR ROM** length is superior to zero, it contains some graphics.\n\nThere are not all the tilesets of the game in the CHR, you can find `0x2000 * len_chr_rom` bytes in it, with two **banks** of `0x1000` bytes, which makes two **images** of 8 kilobytes, there is one bank for one image.\n\nSo, let's take the example of **`Kirby's Adventure`**, below are the graphical data of the CHR rom:\n\n<p align=\"center\" width=\"100%\">\n  <img src=\"/kirby1.png\">\n  <img src=\"/kirby2.png\">\n</p>\n\nThere are only four colors because the rest is calculated at runtime.\nBelow are the main parts of code that generate this 2 images:\n\n### Colors\n```rust\ntype Rgb = (u8, u8, u8);\n\nconst BLACK_PIXEL: Rgb = (0, 0, 0);\nconst COLOR_SCHEME: [Rgb; 4] = [\n    (0, 0, 0),\n    (126, 126, 126),\n    (189, 189, 189),\n    (255, 255, 255)\n];\n\nfn bits_to_rgb(left: u8, right: u8) -> Rgb {\n    let color = right << 1 | left;\n\n    COLOR_SCHEME[color as usize]\n}\n```\n\n### Bytes to RGB\n```rust\npub fn fill_with_bank(&mut self, bank: &[u8]) {\n    let mut mem_x = 0;\n    let mut mem_y = 0;\n\n    for byte in (0..bank.len()).step_by(16) {\n        for y in 0..8 {\n            if mem_x >= NesImage::W {\n                mem_y += NesImage::TILE_H;\n                mem_x = 0;\n            }\n\n            let lower = bank[byte + y];\n            let upper = bank[byte + y + 8];\n\n            for bit in 0..8 {\n                let pixel = bits_to_rgb(\n                    lower >> (7 - bit) & 1,\n                    upper >> (7 - bit) & 1\n                );\n                self.put_pixel(bit + mem_x, y + mem_y, pixel);\n            }\n        }\n        mem_x += NesImage::TILE_W;\n    }\n}\n```\n\n# Disassembling\n\nThe bytecodes are in the **PGR ROM** (**Program Read-Only Memory**) of size `0x4000 * len_chr_rom` (value in the header) bytes.\n\nSo, for **`Kirby's Adventure`**, the assembler code should looks like:\n\n```asm6502\n; Mapped registers\n\nSQ1_VOL equ $4000\nSQ1_SWEEP equ $4001\nPPUMASK equ $2001\nSQ1_LO equ $4002\nSQ1_HI equ $4003\nSQ2_SWEEP equ $4005\n...\n\n; Header\n\nhex 4e 45 53 1a\nhex 20\nhex 20\nhex 43\nhex 00\nhex 00\nhex 00\nhex 00\nhex 00 00 00 00 00\n\n; PRG ROM\n\nand ($0f, x)      ; 21 0f\nslo $280f         ; 0f 0f 28\nslo $2121         ; 0f 21 21\njsr $2020         ; 20 20 20\njsr $0221         ; 20 21 02\nslo $200f         ; 0f 0f 20\nand ($0f, x)      ; 21 0f\n...\n```\n\n# Game Genie code\n\n- *The Game Genie is a enhancement cart for the NES designed by Camerica and distributed by Galoob and Cameric*\n- *it provides a simple interface to enter up to three cheat codes*\n\n*Source: [NesDev Wiki](https://www.nesdev.org/wiki/Game_Genie)*\n\nObviously I didn't buy the enhancement cart, so I can't use the available codes. But on some emulators it is possible to access the memory and inject values.\n\nSo I made a feature that decodes the **Game Genie** codes.\n\nFor example for **`Kirby's Adventure`**, it is possible to have infinite energy with the following code:\n\n```\n$ nes-utils-cli --code SZEPSVSE    \nAddress 0x1e05\nValue 0xad\nCompare value 0x8d\n```\n",
            "url": "http://localhost:3000/post/nes-utilities",
            "title": "NES library",
            "summary": "The library contains useful features like a disassembler, graphic extraction (to PNG) from CHR ROM and a Game Genie encoder/decoder.",
            "date_modified": "2022-09-22T00:00:00.000Z",
            "author": {
                "name": "Théo Bori",
                "url": "https://www.github.com/theobori"
            }
        }
    ]
}